\chapter{Introdução}

Uma das principais preocupações da Engenharia de Software atualmente é a confiabilidade de sistemas e processos de desenvolvimento de software \cite{ROSS:1975} \cite{SOMMERVILLE:2011}. Definida como a prevenção de falhas na concepção, projeto e construção de software, além da capacidade de recuperação de falhas em operação e performance, a confiabilidade de sistemas é dita por Ross como uma preocupação "tardia"\ da Engenharia de Software, muitas vezes ignorada em favor de eficiência.

\citeonline{LYU:1996} apresenta diversas razões para esta preocupação, dentre elas o crescimento dramático do tamanho e complexidade de sistemas computacionais e a forma como sistemas computacionais permeiam quase todas as áreas da sociedade. Como forma de medir a confiabilidade de sistemas, diversos autores \cite{LYU:1996}\cite{MUSA:1979}\cite{REUSSNER:2003} utilizam o quantificar \textit{Mean Time to Failure} (MTTF), ou tempo médio até falha em português. Esta medida é, em todos os casos citados acima, realizada através do teste de software.

Independentemente das abordagens utilizadas, duas técnicas se destacam nos trabalhos de diversos autores \cite{JIFENG:2005}\cite{SELIC:2003}\cite{CZARNECKI:2000}\cite{STAHL:2006}\cite{CRNKOVIC:2002a}\cite{CLEMENTS:2001} como uma forma de diminuir consideravelmente o esforço de desenvolvimento e aumentar a confiabilidade de sistemas de software: o reuso de componentes de software testados e maduros, e; a geração automática de código a partir de modelos conceituais.

\citeonline{SELIC:2003} apresenta preocupação sobre o quão atrasada é a Engenharia de Software em buscar melhoras na confiabilidade e produtividade de software. O autor propõe a geração de código automática, a partir de modelos conceituais, como sendo uma mudança fundamental nos paradigmas de desenvolvimento de software, com o potencial de alterar a Engenharia de Software de formas que não são vistas desde a invenção de compiladores a mais de cinquenta anos.

Já \citeonline{JIFENG:2005} citam dentre as regras de restrição de um componente de software a composição por componentes de terceiros, ressaltando a importância da utilização de componentes de software maduros e testados na composição de sistemas confiáveis. \citeonline{CZARNECKI:2000} e \citeonline{CLEMENTS:2001} reforçam ainda mais a necessidade da criação de grupos de componentes em comum para que a evolução de cada componente seja propagada dentre diversos sistemas.

Os autores citados propõe várias abordagens e tecnologias para a prática dos conceitos propostos nas áreas de geração automática de código e reuso de componentes de software. Destas, se destacam neste estudo a Engenharia de Software Baseada em Componentes (CBSE - Component-Based Software Engineering) \cite{CRNKOVIC:2002a}, Programação Generativa (GP - Generative Programming) \cite{CZARNECKI:2000} e o Desenvolvimento Dirigido por Modelos (MDD - Model-Driven Development) \cite{STAHL:2006}.

CBSE se destaca pela identificação de características de software e sua implementação na forma de componentes reutilizáveis, possibilitando a geração de sistemas a partir da composição por partes já mais maduras e confiáveis do que a construção de um sistema inteiramente novo \cite{CRNKOVIC:2002a}. \citeonline{BREIVOLD:2007} citam a facilidade de manutenção de sistemas complexos baseados em CBSE e seu alto grau de uso em sistemas Web, e \citeonline{CRNKOVIC:2000} mencionam que o grau de reuso possibilitado por práticas de CBSE varia desde o reuso de grandes componentes englobando diversas funcionalidades, até o reuso de pequenos blocos de código.

MDD se destaca pelo seu foco em uma documentação minuciosa de um produto de software, tendo a implementação em segundo plano e preferencialmente de forma automatizada, buscando permitir melhor visualização e manutenção do produto \cite{STAHL:2006}. \citeonline{TAYLOR:2009} citam a importância de uma documentação completa de sistemas de software que possibilite o reuso de partes de sistemas ou até sistemas inteiros em vista do alto grau de compreensão de desenvolvedores que é obtido através do foco em documentação.

GP busca minimizar os trabalhos de programação através da automação de geração de código, realizada pela identificação e formalização das características comuns entre sistemas e a criação de geradores de componentes que os compõe a partir de subcomponentes pré-determinados \cite{CZARNECKI:2000}. \citeonline{BATORY:2004} menciona a abordagem GP como sendo o futuro da engenharia de software, ressaltando a importância de abordagens abrangentes para a geração de sistemas ao invés do uso de soluções \textit{ad hoc}.

O estudo das abordagens de MDD e GP, além de publicações específicas demonstrando a aplicação de abordagens baseadas em modelos na área de desenvolvimento Web \cite{POLAK:2015}\cite{VALVERDE:2009}, permitiu concluir que é possível a geração de APIs de acesso a estruturas de dados a partir de modelos conceituais que sirvam como modelos de configuração para a geração destas APIs. A aplicação de técnicas de CBSE permite a criação de subcomponentes reutilizáveis na geração destas APIs, na forma de blocos de código parametrizáveis, aumentando consideravelmente a confiabilidade dos sistemas gerados e a produtividade no seu processo de geração.

No que concerne às diferentes abordagens arquiteturais para o desenvolvimento de software, podemos destacar a arquitetura de cliente-servidor em \citeonline{REESE:2000} e a de sistemas em camadas de \citeonline{garlan:1993}. Também enquadra-se dentro de arquiteturas a REST (\textit{REpresentational State Transfer}) \cite{FIELDING:2000} que é uma arquitetura focada na comunicação de rede de um sistema, sendo uma das bases da Web.

O objetivo principal deste trabalho é propor: um paradigma baseado nas metodologias citadas acima (MDD, GP, CBSE) para a modelagem conceitual de APIs REST; métodos e algoritmos para a conversão destes modelos em formatos que permitam facilidade de compreensão humana e processamento por máquinas, e; o desenvolvimento de um protótipo de sistema de software que aplique este paradigma para a geração automática do código de APIs REST a partir de um esquema conceitual representado em um diagrama de classes da UML. As classes e seus atributos serão complementados com anotações (\emph{tags}) em JSON Schema a fim de permitir maior refinamento destes esquemas conceituais; estas servirão para representar restrições de integridade das estruturas de dados e permitir a geração de APIs com acesso a bases de dados de persistência. As APIs REST geradas suportam as operações básicas de manutenção dos documentos, comumente referidas como CRUD (\textit{Create, Read, Update, Delete}), através da composição de blocos de código parametrizáveis representando os principais métodos HTTP.

O trabalho está organizado da seguinte forma: No capítulo \ref{chap:modelagem} são apresentados os conceitos básicos sobre determinadas metodologias de desenvolvimento de software, seguidos de uma breve apresentação das linguagens UML e JSON. No capítulo \ref{chap:arquitetura} são apresentadas as arquiteturas Cliente/Servidor, REST e HTTP, que são a base das APIs que se busca gerar com a solução deste estudo. No capítulo \ref{chap:tecno} são apresentadas as tecnologias que foram utilizadas na solução do problema proposto.

No capítulo \ref{chap:autorest} é apresentada a solução proposta por este estudo, composta de uma arquitetura independente de tecnologia e a modelagem de uma ferramenta como prova de conceito. São apresentadas todas as regras de modelagem e de geração da ferramenta prova de conceito, além de uma apresentação da ferramenta e de seu funcionamento. O capítulo \ref{chap:concl} apresenta a conclusão deste trabalho, além de trabalhos relacionados e a descrição de possíveis trabalhos futuros. Para a organização das contribuições deste trabalho no último capítulo, e para a orientação do leitor durante o estudo deste volume, são propostas as seguintes questões de pesquisa que são representativas dos desafios encontrados:

\begin{itemize}
  \item QP1. Existe viabilidade na automação da geração de uma API REST utilizando uma abordagem baseada em MDD?
  \item QP2. Quais os elementos necessários para a representação completa de uma API REST em um modelo gráfico para que este possa ser utilizado como modelo de configuração em uma abordagem MDD para a geração de uma API com todas as funcionalidades CRUD fundamentais?
  \item QP3. Existe a necessidade de criação de um modelo intermediário, a partir de um modelo de configuração, que sirva como artefato de entrada para um gerador de APIs REST?
  \item QP4. As APIs REST são suficientemente modularizáveis a ponto de permitir a geração automática de código a partir de blocos de código parametrizáveis? Qual a complexidade de se criar um compilador de APIs REST que não se utiliza de uma abordagem GP?
  \item QP5. É possível a geração automática de um banco de dados auxiliar à API REST?
  \item QP6. Diagramas de Classes UML são uma notação adequada para a modelagem de APIs REST?
  \item QP7. Arquivos JSON Schema são adequados para a representação de APIs REST?
  \item QP8. O SGBD MongoDB, a linguagem Node.js e a biblioteca Mongoose são adequadas como tecnologias para a geração automática de APIs REST?
\end{itemize}
