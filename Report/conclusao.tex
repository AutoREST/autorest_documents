\chapter{Considerações Finais}
\label{chap:concl}

Neste trabalho, foi proposta uma solução para o problema de geração automática de APIs REST que provejam as funcionalidades necessárias para que sejam executadas as operações básicas de manutenção de documentos (CRUD - \textit{Create, Read, Update, Delete}), com o objetivo de utilizar a geração automática de código como uma forma de aumentar a confiabilidade e produtividade do processo de criação de software.

A solução AutoREST aplica os conceitos das metodologias de Engenharia de Software Baseada em Componentes, Desenvolvimento Dirigido por Modelos e Programação Generativa, concretizando heurísticas de cada uma destas metodologias em uma proposta de arquitetura de software. Além disto, propomos uma ferramenta como prova de conceito da arquitetura proposta, que servirá como instanciação desta arquitetura.

Este trabalho foi motivado pelo formalismo da arquitetura REST e a representatividade das notações JSON Schema e Diagrama de Classes UML. Através destas notações, foi possível a proposição de regras de modelagem que permitam a representação conceitual de uma API REST. Além disto, dada a estrutura da notação JSON Schema, que é baseada na Backus-Naur Form (BNF), foi possível a proposição de um método para a conversão da um documento JSON Schema em código fonte da API representada.

A arquitetura proposta, além dos componentes descritos para a instanciação desta arquitetura em uma prova de conceito, foram construídos a partir do estudo da arquitetura REST, do \textit{Hypertext Transfer Protocol} (HTTP) e das notações JSON Schema e UML, esta última particularmente no que concerne o conjunto da UML que é disponibilizado pela ferramenta Astah. Além destas tecnologias, foram estudadas a linguagem Node.js, o sistema gerenciador de bancos de dados MongoDB e o módulo Node.js Mongoose, que serão utilizados pelas APIs REST geradas pela ferramenta proposta.

%------------------------------------------------------------

\section{Trabalhos Relacionados}
\label{sec:related}

Dentre os trabalhos encontrados que tratem de geração de código automática, foram selecionados alguns que tratam especificamente de ferramentas para a geração automática de código a partir de definições em formato JSON Schema ou similar. Se destacaram em nossa pesquisa as ferramentas Heroics, Schematic, Swagger e Eve. Além disso, damos destaque as ferramentas DaemonX e Prmd, que utilizam alterações na especificação de APIs para gerar a documentação e versionamento delas automaticamente.

%------------------------------------------------------------

\subsection{Heroics and Schematic}

Heroics é um gerador que utiliza um JSON Schema que representa uma API para gerar clientes HTTP em Ruby para esta API \cite{HEROICS}. Outro gerador que utiliza uma entrada similar, em JSON Hyper-Schema \cite{JSHYPERSCH}, para gerar clientes HTTP em Go é o Schematic \cite{SCHEMATIC}.

A principal diferença destas ferramentas para o AutoREST é pelo fato de gerarem apenas código cliente. Porem o fato de utilizarem JSON Schema em seus processos pode significar que uma interação com elas seria algo que acrescentaria valor a ferramenta AutoREST, permitindo assim que os clientes da API já fossem criados também.

%------------------------------------------------------------

\subsection{Prmd}

Prmd \cite{PRMD} é uma ferramenta que permite realizar verificação e geração de documentação para APIs utilizando um JSON Schema que a descreve. O JSON Schema utilizado deve possuir algumas características descritas na documentação do Prmd.

Esta é outra ferramenta que utiliza o JSON Schema para um propósito diferente do AutoREST, pois gera documentação para uma API. Como as ferramentas anteriores, esta funcionalidade poderia ser alcançada com uma possível integração de um JSON Schema que descrevesse a REST API gerada.

%------------------------------------------------------------

\subsection{Swagger}

Swagger \cite{SWAGGER} é uma representação de REST APIs com um grande conjunto de ferramentas de apoio ao desenvolvimento e suporte, em quase todas as linguagens de programação atuais. Com uma definição Swagger é possível a geração de documentação e geração de clientes. A especificação Swagger atualmente é gerenciada pela Open API Initiative (OAI) \cite{OpenAPII}.

As definições Swagger e o grande número de ferramentas de geração disponibilizadas pela comunidade proporcionariam o escopo restante no processo de criação de APIs que não é explorado no AutoREST. Uma especificação Swagger gerada pelo AutoREST poderia proporcionar tanto a criação de documentações quanto de códigos clientes da API.

%------------------------------------------------------------

\subsection{Eve}

Eve \cite{IAROCCI:EVE} é um \textit{framework} em Python para a disponibilização de REST APIs. É utilizada uma definição similar a JSON Schema que será interpretada e validada pela ferramenta Cerberus \cite{IAROCCI:CERBERUS}. Esta definição determina o \textit{schema} do \textit{resource} disponibilizado e os métodos HTTP disponíveis para o mesmo.

O \textit{framework} do Eve proporciona uma experiência com uma interação menos explícita com o sistema gerenciador de banco de dados, deixando para o desenvolvedor a tarefa de especificar na gramática da ferramenta Cerberus todos os seus \textit{resources} e artefatos relacionados.

A principal diferença para o AutoREST é que a única coisa que seria necessária criar seria o diagrama de classes, e com este a especificação dos \textit{resources} seria criada e então a API seria gerada com esta especificação sem exigir intervenção no código gerado para que a API comece a ser utilizada.

%------------------------------------------------------------

\subsection{DaemonX}

DaemonX é uma plataforma extensível para o gerenciamento de evolução de documentos representativos de estruturas de dados. Dentre os usos desta plataforma está o de gerenciar a evolução de APIs REST com uma notação baseada no princípio de Arquiteturas Dirigidas por Modelos (MDA - \textit{Model-Driven Architecture}) \cite{POLAK:2015}.

Similar ao Prmd, esta aplicação da plataforma DaemonX apresenta uma forma de representar e gerenciar a evolução de APIs REST, uma funcionalidade não disponível na solução AutoREST. Entretanto, por utilizar uma representação específica, apesar de possivelmente atingir maior detalhamento das APIs, não seria de fácil integração com a solução AutoREST.

%------------------------------------------------------------

\section{Conclusão}

\subsection{QP1. Existe viabilidade na automação da geração de uma API REST utilizando uma abordagem baseada em MDD?}

Esta automação é viável, desde que sejam compreendidos seus pontos positivos e negativos, que no decorrer deste trabalho podemos assumir como sendo:
\begin{itemize}
	\item \textbf{Positivos}
	\begin{itemize}
		\item Para APIs não customizadas após a geração, há alto nivel de compreensão e custo muito baixo após alterações no modelo
		\item Fácil transição de conhecimento sobre o funcionamento da API, sem a necessidade de olhar código fonte e outras estruturas não gráficas
	\end{itemize}
	\item \textbf{Contras}
	\begin{itemize}
		\item APIs customizadas tem seu código customizado perdido no momento de uma nova geração a partir do modelo
		\item É necessário uma boa compreenção das regras de modelagem a serem utilizadas
	\end{itemize}
\end{itemize}

\subsection{QP2. Quais os elementos necessários para a representação completa de uma API REST em um modelo gráfico para que este possa ser utilizado como modelo de configuração em uma abordagem MDD para a geração de uma API com todas as funcionalidades CRUD fundamentais?}

\begin{itemize}
	\item identificadores
	\item navegabilidade entre \textit{resources}
\end{itemize}

\subsection{QP3. Existe a necessidade de criação de um modelo intermediário, a partir de um modelo de configuração, que sirva como artefato de entrada para um gerador de APIs REST?}

Existe se o modelo de configuração for muito abstrato e o gerador de APIs não compreender o mesmo nivel de abstração. No caso da solução apresentada neste trabalho tomou-se a decisão de usar um modelo intermediário que possibilitasse uma validação sintática automática, e uma leitura humana e computacional rápida

\subsection{QP4. As APIs REST são suficientemente modularizáveis a ponto de permitir a geração automática de código a partir de blocos de código parametrizáveis? Qual a complexidade de se criar um compilador de APIs REST que não se utiliza de uma abordagem GP?}

Considerando que a API gerada pela solução apresentada neste trabalho é em Node.js, nós conseguimos uma boa utilização dos blocos de código parametrizáveis (\textit{snippets}). O fato da arquitetura REST impor a divisão em camadas e reforçar o uso de um formato de \textit{resource} no sistema contribuiu para esta modularização. Sem a abordagem GP acreditamos que a implementação poderia ficar maior e mais dificil de manter, pois a necessidade de atualizar um \textit{snippet} geraria um trabalho mais manual.

\subsection{QP5. É possível a geração automática de um banco de dados auxiliar à API REST?}

O trabalho nos leva a concluir que sim, é possivel gerar um banco de dados auxiliar a uma API REST. Algumas incompatibilidades entre a especificação MDD e o banco de dados podem atrapalhar esta geração. Neste trabalho estas imcompatibilidades foram endereçadas gerando uma API mais robusta, e utilizando algumas funções do bando de dados de uma forma semantica especifica, por exemplo a relação de herança entre \textit{resources} foi tratada adicionando um atributo oculto de tipo (\textit{\_\_type}) e armazenando todas as classe filhas na mesma coleção da classe pai.

\subsection{QP6. Diagramas de Classes UML são uma notação adequada para a modelagem de APIs REST?}

Muitos fatores podem influenciar a resposta para esta pergunta, um dos mais importante deles seria a respeito do tipo de banco de dados utilizado. Se o banco de dados for relacional então algumas definições de dados serão levemente alteradas, porem as restrições de relacionamento entre os \textit{resources} serão melhor reforçadas. No caso do banco de dados não for relacional as restrições de relacionamento podem ficar um pouco mais livres, podendo levar a referencias inválidas, porem as definições dos dados possam ser mais fieis ao diagrama de classes.

\subsection{QP7. Arquivos JSON Schema são adequados para a representação de APIs REST?}

\subsection{QP8. O SGBD MongoDB, a linguagem Node.js e a biblioteca Mongoose são adequadas como tecnologias para a geração automática de APIs REST?}

%------------------------------------------------------------

\section{Trabalhos Futuros}

Diversos trabalhos podem ser realizados expandindo o tema deste estudo. Nesta seção, definimos alguns temas que surgiram ao longo da realização do estudo, mas que por estar além do escopo proposto ou requirir um dispêndio de tempo não disponível, não foram explorados.

\begin{itemize}
    \item A ferramenta Astah é extensível através do uso de \textit{plugins}. A implementação de um \textit{plugin} Astah para a geração de modelos de configuração segundo as especificações deste trabalho seria de grande ajuda na modelagem de APIs REST e execução de ferramentas AutoREST. Dentre os requisitos que este \textit{plugin} deverá cumprir estão a criação automática de \textit{tags} conforme as especificações da Seção \ref{sec:xmi}, a limitação dos tipos de atributos disponíveis, a limitação dos tipos de associação disponíveis e uma interface de ajuda que apresente as regras listadas na Seção \ref{sec:xmi} para fácil acesso a referência.

    \item Algumas das ferramentas listadas na Seção \ref{sec:related} permitem: a geração automática de código para funcionalidades diferentes das propostas pela solução AutoREST, e; o gerenciamento da documentação e versionamento de APIs REST. Visto que algumas destas ferramentas utilizam especificações em notações derivadas de JSON, seria útil a adequação das especificações destas diversas ferramentas e a integração de seus ambientes para execução em conjunto.

    \item Devido a limitações da ferramenta Astah, determinados tipos de associação disponíveis na UML não puderam ser definidos para modelagem neste estudo. A definição de regras para a modelagem e conversão destes tipos de associação seria útil para aumentar a versatilidade da solução proposta. Dentre estas associações, se destacam: as associações de Generalização/Especialização para representar o conceito de herança múltipla; o uso dos esteriótipos \textit{Disjoint} e \textit{Overlapping} para associações de Generalização/Especialização, e; a definição de navegabilidade em associações de agregação.

    \item A modelagem e implementação da ferramenta usada como prova de conceito da arquitetura proposta está limitada as tecnologias determinadas em sua especificação. A criação de outras possíveis implementações da arquitetura AutoREST serviria para validar a sua proposta de independência de tecnologia. Tecnologias que poderiam ser utilizadas para diferentes implementações são: para modelos de configuração, Diagramas de Classes UML gerados por ferramentas diferentes do Astah, ou Modelos Entidade-Relacionais; para PFIS, estruturas em linguagem RAML, Swagger ou WSDL, e; para geração de código, linguagens como ASP.NET ou php.
\end{itemize}
